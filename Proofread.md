**校对目录 (Table of Contents)**

# 一、Home 首页
## 1、What is Haystack？
Project Haystack is an open source initiative to streamline working with data from the Internet of Things. We standardize semantic data models and web services with the goal of making it easier to unlock value from the vast quantity of data being generated by the smart devices that permeate our homes, buildings, factories, and cities. Applications include automation, control, energy, HVAC, lighting, and other environmental systems.

原译：Project Haystack是一个关于楼宇设备和运行数据的标签规则与分类的开源协议。我们定义与能源、暖通空调、照明等环境系统相关的站点、设备以及数据节点的标准数据模型。通过REST API定义，以便于Haystack通过互联网交换数据。

校对：Project Haystack是一个旨在简化与物联网相关的数据的开源计划。我们将语义数据模型和网络服务标准化，目的是为了更轻松地从渗透到我们家庭、建筑物、工厂和城市的智能设备所产生的大量数据中获取价值。应用包括自动化，控制，能源，暖通空调，照明和其他环境系统。

解析：原译未按照原文逐句翻译，可行。


## 2、Who Should Participate？
System integrators and manufacturers who integrate Haystack support into their projects and products are positioned for the future of value added services.

原译：那些将Haystack集成到项目和产品中的集成商与制造商，**将被定位在**未来的增值服务。

校对：那些将Haystack集成到项目和产品中的集成商与制造商，**将定位于**未来的增值服务。


## 3、Open Source
Anyone is free to participate as long as contributed IP is licensed under the AFL. This ensures that Haystack IP is open and freely available for any commercial use.

原译：**任何自由参与者的参与时长依据贡献程度决定，其IP具备AFL授权**。

校对：只要其IP获得AFL许可，任何人都可以自由参与。

解析：原译错误


# 二、About 关于
## 1、About Project Haystack
Project Haystack is a 501C tax-exempt non-stock corporation formed May 28, 2014 under the provisions of Chapter 10 of Title 13.1 of the Code of Virginia of 1950. The corporation functions as a trade association with the purpose of fostering the common association and interests of software and technology companies focused on developing semantic modeling solutions for data related to smart devices including: building equipment systems, automation and control devices, sensors and sensing devices, promotion and education with respect to the semantic data modeling industry for building automation systems, and to engage in educational activities directed towards the improvement of business conditions of the semantic data modeling industry for smart device data, all on a not-for-profit basis, as provided in Section 501(c)(6) of the Internal Revenue Code of 1986, as amended (the “Code”).

原译：Project Haystack是一个成立于2014 年5月28日的501 C 免税非股份制公司，其遵循1950年的《弗吉尼亚法典》**第10章标题 13.1 的的**规定。作为一个贸易协会，**其目的是促进共同协会与软件科技公司的利益**,其专注于开发与智能设备包括相关的数据的语义建模解决方案，包括：楼宇设备系统、 自动化和控制设备、 传感器和**遥感**设备，关于楼宇自动化系统**行业**的语义数据建模的推广、 教育，及针对智能设备数据的语义数据建模所从事教育活动，**依据1986年国内税收法典501(c)(6)节代码，经修正后 （"Code"）**，所有这些都建立在不以营利为目的基础上。

校对：Project Haystack是一个成立于于2014年5月28日的501C免税非股份制公司，其遵循1950年《弗吉尼亚州法典》**第13.1节第10章的规定**。作为贸易协会，**其目的是促进软件科技公司的共同关系和利益**，这些公司致力于开发与智能设备有关的数据的语义建模解决方案，包括：楼宇设备系统，自动化和控制设备，传感器和传感设备，关于楼宇自动化系统的语义数据建模产业的推广和教育，**并根据《国内税收法典》（以下简称“法典”）1986年修订版第501(c)(6)条的规定**，从事旨在改善语义数据建模产业智能设备数据业务条件的教育活动，所有这些都建立在不以营利为目的基础上。

解析：
+ 章节条款描述：《法典》第13.1节第10章
+ “致力于开发与智能设备有关的数据的语义建模解决方案”的主语为“软件科技公司”而非贸易协会。
+ 法典描述：并根据《国内税收法典》（以下简称“法典”）1986年修订版第501(c)(6)条的规定


All work developed by the project-haystack.org community is provided for use as open source software under the Academic Free License 3.0.

原译：由项目 haystack.org 社区开发的所有工作被都可作为开放源码软件在遵循 Academic Free License 3.0.

校对：所有由project-haystack.org社区开发的工作都作为遵循Academic Free License 3.0的开源软件供使用。


## 2、Board of Directors 董事会
The management and operations of the Corporation are governed by a Board of Directors of the Corporation. 

原译：公司的管理和运作公司受公司取决于公司的董事会。

校对：公司的管理和运作由公司董事会管理。


# 三、Docs 文档
## 1) 简介
### 1.3 Rest Http API
To facilitate interoperability between Haystack software systems, a simple REST API is definde to exchange data over HTTP:

原译：为了促进Haystack软件系统之间的互操作性，**一个简单的REST API就是通过HTTP交换数据:**

校对：为了促进Haystack软件系统之间的互操作性，**定义了一个通过HTTP交换数据的简单的REST API：**

### 本章其他翻译建议：
+ to get start 译作“开始之前”
+ exchange 就直译作“交换”，而非“读写”
+ building operations 译作“建筑运营”，而非“建筑作业”
+ 系统和设备术语应参阅专业文献

## 2) TagModel 标签模型
### 2.1 元模型
In oBIX the metamodel is oBIX contracts. In RDF the metamodel is subject-predicate-object triples.

原译：在oBIX中，元模型是**oBIX合约**。在RDF中，元模型是**主体谓词** - 对象三元组。

校对：在oBIX中，元模型是**oBIX协议**。在RDF中，元模型是**主语-谓语-宾语** - 对象三元组。


However, the rigid structures imposed by OO class hierarchies or relational database schemes is ill suited to the domain of building automation systems where each project is essentially unique.

原译：然而，由OO类层次结构或关系数据库方案强加的刚性结构不适合楼宇自动化系统的领域，每个项目基本上都是唯一的。

校对：然而，像面向对象的类层次结构或关系型数据库这样的刻板结构并不适合楼宇自动化系统的领域，因为每个项目基本上都是独一无二的。

### 2.2 实体
If a specific definition of an entity is stored in a database, then we will use the term record or rec interchangeably with the term entity. We often the use the term rec in dicussions of the REST API where clients interact with a server database of haystack entities.

原译：如果具体定义存储在数据库中的实体，那么我们将使用 术语记录 或者与 术语实体 进行rec可互换。我们经常使用 REST API 中的术语rec，其中客户端与haystack实体的服务器数据库进行交互。

校对：如果一个实体的具体定义被存储在数据库中，那么我们将使用术语record或rec与实体（entity）互换。我们经常使用REST API中的术语rec来描述客户端与haystack实体的服务器数据库间的交互。

解析：原译不自然。

### 本章其他翻译建议：
+ building equipment and operations 译作“建筑设备和运营”而非“建筑设备和作业”

### 2.3 标签
#### 2.3.1 标签名称
By convention use camel case

原译：按惯例使用**骆驼写法**

校对：按惯例使用**驼峰命名法**


Restricting tag names, ensures they may be easily used as identifiers in programming languages and databases.

原译：禁止使用标签名称，确保它们可以正确地用作编程语言和数据库中的标识符。

校对：限制使用标签名称，确保它们可以方便地用作编程语言和数据库中的标识符。

解析：禁止还是建议？

#### 2.3.2 标签种类
A kind is one of the permitted value types of a tag. The following are the atomic scalar tag kinds: 

原译：这个标签类别是下面允许值类型的标签之一。以下是原子标量类型：

校对：一个标签种类是指标签所允许某个值类型。以下是原子标量标签类型：


singleton value which represents not available for missing data

原译：**表示不可用于丢失数据的单例值**

校对：单例值，表示缺失数据，且无法获取

解析：原译错误


integer or floating point number annotated with an optional unit of measurement.

原译：用可选的测量单位[注释]'Units' 的整数或浮点数。

校对：某点位的整型或浮点型数据，并标注一个可选的测量单位。


Bin: a binary blob with a MIME type formatted as Bin(text/plain)

原译：**具有格式为MIME类型的二进制 Bin(text/plain)**

校对：格式为Bin(text/plain)的MIME类型的二进制大对象。

解析：原译错误


an ISO 8601 date as year, month, day: 2011-06-07.
an ISO 8601 time as hour, minute, seconds: 09:51:27.354.

原译：ISO 8601日期为年，月，日：2011-06-07。

校对：ISO 8601标准日期，例如“年月日”表示为：2011-06-07。


There are three collection tag kinds:

原译：有三种**收藏**标签种类：

校对：有三种**集合**标签类型：

解析：计算机术语

### 2.4 Id
The id tag is used model the unique identifier of an entity in system using a Ref value type. The scope of an entity is undefined, but must be unique with a given system or project. This identifier may be used by other entities to cross-reference using tags such as siteRef, ahuRef, etc.

原译：**该 id 标记用于在模型系统中使用的实体的唯一标识 Ref 值的类型。**实体的范围未定义，但必须在给定的系统或项目中是唯一的。这个标识符可以由其它实体来**交叉参考**使用标签如 siteRef， ahuRef等

校对：**id标签使用Ref值类型对系统中的实体的唯一标识进行建模。**虽然实体的范围未定义，但在给定的系统或项目中必须是唯一的。该标识符可被其他实体用来**交叉引用**诸如 siteRef，ahuRef等正在使用的标签。

解析：原译有误


The dis tag is used with all entities as the standard way to define the display text used to describe the entity. Dis values should be short (less than 30 or 40 characters), but fully descriptive of the entity.

原译：**这个 dis 标签与所有实体一起用作定义用于描述实体的显示文本的标准方式**。Dis值应该较短（小于30或40个字符），但完全描述实体。

校对：**dis 标签被用于所有实体，它是定义描述实体的显示文本的标准方式**。Dis标签的值应当简短（小于30或40个字符），但又能充分描述实体。

解析：原译不自然。


In the example above we have an entity with seven tags: id, site, dis, area, geoAddr, tz, and weatherRef. By convention when writing examples we will list each tag on their own line or separated by a comma. The site tag has no explicit value, so it is assumed to be marker tag. The dis, geoAddr, and tz tags have string values indicated by double quotes. The area tag has a number value indicated by a scalar with unit of square feet. The weatherRef tag is a reference to another entity, which we indicate using the "@" character.

原译：在上面的例子中，**我们有七个标签实体：** id, site, dis, area, geoAddr, tz, 和 weatherRef。按惯例编写示例时，我们**将在自己的行上列出每个标签**或用逗号分隔。这个 site 标签没有明确的意义，因此它被认为是标志标签。这个 dis， geoAddr 和 tz 标签 有双引号表示的字符串值。这个 area 标签具有由**一个标量与平方英尺单元所指示**的数字值。 weatherRef 标签是指向另一个实体，我们使用“@”字符的作为开头。

校对：在上面的例子中，**我们有一个包含七个标签的实体：**id，site，dis，area，geoAddr，tz和weatherRef。 按惯例编写示例时，我们**将分行列出每个标签**或用逗号分隔。site标签没有明确的值，因此它被看做标识标签。 dis，geoAddr和tz标签具有双引号表示的字符串值。区域标签**具有以平方英尺为单位的标量表示**的数字值。 weatherRef标签是对另一个实体的引用，我们使用“@”字符表示。

解析：原译不自然。


## 3) Structure 结构
### 3.1 概述
single building with its own street address

原译：单一建筑物拥有自己的街道地址

校对：拥有其街道地址的单体建筑

### 3.2 容器
校对：[reference tags]‘TagModel#tagKinds’ markdown语法错误导致显示问题，全站有多处此类问题，需逐一排查。

### 3.3 站点
A site entity models a single facility using the site tag. A good rule of thumb is to model any building with its own street address as its own site. For example a campus is better modeled with each building as a site, versus treating the entire campus as one site.

原译：一个*site*的实体使用 site 标签建立一个**单一的设备**。好的经验法则是建模楼宇的时，以其街道地址作为它自己的站点。例如，**为校园建模的时候，把整个校园作为一个站点好过把每一个建筑作为一个站点。**

校对：站点实体使用 site 标签对**单个设施**进行建模。在对任何楼宇进行建模时，一个很好的经验法则是将其街道地址作为自己的站点。 例如，**在对校园进行建模时，更好的方式是把每个建筑物作为一个站点，而不是把整个校园作为一个站点。**

解析：原译开头和最后一句翻译错误。


square footage or square meters of the facility. This enables site normalization by area.

原译：**平方英尺或平方米的设施。这使得按地区进行现场规范化。**

校对：设施的平方英尺或平方米。这使得站点通过面积进行规范。

解析：原译有误


associate the site with a weather station to visualize weather conditions and perform weather based energy normalization

原译：将该站点与气象站相关联，以便可视化天气状况并执行基于天气的能量归一化

校对：

解析：能量归一化是否准确？待研究


four digit year in which the building was constructed

原译：建筑物四位数的年份

校对：建筑物四位数的建造年份


Here is an example of a site entity fully tricked out with geolocation tags:

原译：以下是一个使用地理位置标签充分的展示网站实体的示例：

校对：以下是一个使用地理位置标签充分展示一个站点实体的示例：

**其他翻译建议：**
+ chiller 译作“冷水机”，chiller plant译作“冷水机组”
+ schedule 译作“时间表”而非“进度表”

### 3.5 点
model analog ponts such as temperature or pressure. These points should also include the unit to indicate the point's unit of measurement.

原译：模拟**模拟字体，如温度或压力**。这些点也应包括 unit 指示点的测量单位。

校对：模拟**诸如温度或压力等模拟量的点**。这些点也应该包含 unit 用以指示该点的测量单位。

解析：数字量和模拟量


When these tags are applied to a cmd or sp, they model the range of valid user inputs when commanding the point.

原译：当这些标签应用于 cmd 或者 sp ，在命令点时，它们建模有效的用户的输入范围。

校对：当这些标签应用于 cmd 或 sp，在对点执行指令时，它们规范有效的用户输入范围。


The term cur indicates synchronization of a point's current real-time value. By real-time we typically mean freshness within the order of of a few seconds.

原译：术语“cur”表示一个点的当前实时值的同步。**实时通常意味着在几秒钟之内的新鲜度。**

校对：术语“cur”表示点的当前实时值的同步。**实时通常意味着每过几秒钟就会更新一次。**


current value of the point as Number, Bool, or Str

原译：点数的当前值为Number，Bool或Str

校对：点的当前值，可以是Number，Bool或Str


Writable points are points which model an output or setpoint and may be commanded. Writable points are modeled on the BACnet 16-level priority array with a relinquish default which effectively acts as level 17. Writable points which may be commanded by the pointWrite operation should be tagged with the writable tag.

原译：可写点是对输出或设定值进行建模并**可能被命令的点**。可写点在BACnet 16级优先级数组上建模，**具有默认值**，可有效地作为17级.可以被[pointWrite]‘Ops#pointWrite’命令操作的可写点应该用标签'writable'标记。

校对：可写点是对输出或设定值进行建模并**可被指令控制的点**。可写点在BACnet 16级优先级数组上建模，作为有效的第17级，**而非默认值**。可写点可以由 pointWrite 操作发送指令，并使用 writable 标签进行标记。


highest priority reserved for emergency overrides

原译：最高优先级保留用于紧急**重读**

校对：最高优先级，被保留用于紧急情况下的**覆写**


The priority array provides for contention resolution when many different control applications may be vying for control of a given point. Low level applications like scheduling typically control levels 14, 15, or 16. Then users can override at level 8. But a higher levels like 2 to 7 can be used to trump a user override (for example a demand response energy routine that requires higher priority).

原译：当许多不同的控制应用程序争夺给定点的控制时，优先级数组提供了争用解决方案。诸如调度这样的低级应用程序通常控制级别为14,15或16.那么用户就可以在级别8上进行覆盖。但是使用更高级别（如2到7）**好过用户覆盖（例如一个响应常规能源的需求，需要更高的优先级）。**

校对：当许多不同的控制应用程序可能争夺给定点的控制权时，优先级数组提供了争用解决方案。诸如时间表这样的的低级应用程序通常控制级别为14,15或16。那么用户可以在级别8上覆写。但是可以使用更高级别（如2到7）**来胜过用户覆写（例如一个需要更高级别需求响应的能源事务）。**


The actual value to write is resolved by starting at level 1 and working down to relinquish default to find the first non-null value. It is possible for all levels to be null, in which case the overall write output is null (which in turn may be auto/null to another system). Anytime a null value is written to a priority level, we say that level has been set to auto or released (this allows the next highest level to take command of the output).

原译：要写入的实际值通过从第1级开始解析，**并处理默认值**来找到第一个非空值。所有级别都可以为空，在这种情况下，总写入输出为空（这又可能是另一个系统的自动/空值）。任何时候，一个空值被写入一个优先级，我们说这个级别已被设置为自动或释放（这允许下一个最高级别来**命令输出值**）。

校对：要写入的实际值通过从第1级开始解析，**并且逐级下调至默认值**以找到第一个非空值。在所有级别都为空的情况下，总写入输出为空（这又可能是另一个系统的自动/空值）。无论何时将空值写入优先级，我们认为该级别已设置为自动或释放（这允许下一个最高级别**对输出进行控制**）。


optionally defined to indicate a point is collected an ongoing accumulated value

原译：可选地定义为指示一个点被收集正在进行的累积值

校对：该标签可选，表示该点是否记录了持续的累计值。


apparent temp，dew temp，barometric pressure，cloudage

原译：
+ 被认为“感觉像”温度在单位 °C or °F
+ 温度以°C或°F为单位，低于此水冷凝
+ 大气压（毫巴）或以毫巴（Hg）计
+ 云彩朦胧的天空百分比

校对：
+ 体感温度
+ 露点温度
+ 大气压力（毫巴或英寸汞柱）
+ 云量


historized trend of sunrise/sunsets as true/false transitions

原译：日出/日落的历史趋势是 真/假 过渡

校对：日出/日落的历史趋势，以 true/false 值记录


Weather points are associated with their weather entity using the weatherRef tag.

原译：天气点**与使用 weatherRef 标签的天气实体**相关联。

校对：天气点**使用 weatherRef 标签与其天气实体**相关联。


We often model both local weather sensors and data from an official weather station. Local sensors are typically used for HVAC control sequences. But we might use official weather data for checking local sensor calibration or baseline energy normalization. In Haystack, weather station data is annotated with weatherPoint and site-local sensors with outside:

原译：我们经常**模拟来自官方气象站的当地天气传感器和数据**。本地传感器通常用于HVAC控制序列。但是我们可能会使用官方天气数据来检查本地传感器校准或基准能量归一化。在Haystack，气象站数据用'weatherPoint'标注和现场本地传感器用'outside'标注：

校对：我们经常**模拟本地的气象传感器和官方气象站的数据**。本地传感器通常用于HVAC控制序列。 但是我们可能会使用官方天气数据来检查本地传感器校准或基准能量归一化。在Haystack中，气象站数据用 weatherPoint 标注，而本地站点传感器使用 outside 标注：

解析：checking local sensor calibration or baseline energy normalization. 如何翻译待研究

## 4) TimeZones 时区
### 4.1 概述
Time-series data is the foundation for the sensor and operational data. This makes it critical to define a proper, unambiguous representation of time and timezones. Timezones are identified using the tz tag with a city name from the zoneinfo database (discussed below).

原译：时间序列数据是传感器和操作数据的基础。这使得定义时间和时区的正确，明确的表示成为关键。使用 tz 标签来自[zoneinfo database]‘http://en.wikipedia.org/wiki/Tz_database’ 的城市名称的标签（下面讨论）识别时区。

校对：时间序列数据是传感器和运行数据的基础。这使得定义恰当且明确的时间和时区尤为关键。时区使用来自时区信息数据库的城市名称的 tz 标签（如下所述）来标识。


offset from UTC and daylight saving time rules

原译：**从UTC和夏令时规则偏移**

校对：**UTC偏移量和夏令时规则**


Timezones are quite problematic for computers because they are a political abstraction versus a scientific abstraction. This means that a given region might change its timezone rules (either UTC offset of DST rules) over time. For example, in 2007 the US changed the dates for when DST starts and ends. This means that computing a date in 2000 uses different rules than 2010 (we call these historical timezones).

原译：时区对于计算机来说是**相当有问题的，因为它们是政治抽象与科学抽象**。这意味着给定的区域可能随时间改变其时区规则（DST规则的UTC偏移量）。例如，2007年，美国更改了DST开始和结束的日期。这意味着在2000年的计算日期使用与2010年不同的规则（我们称之为这些历史时区）。

校对：时区对于计算机来说是**很难处理的，因为它们是一种政治概念而不是一种科学的概念**。 这意味着给定的区域可能会随时间改变其时区规则（DST规则的UTC偏移量）。例如，2007年，美国更改了DST开始和结束的日期。 这意味着，计算2000年的日期使用与2010年不同的规则（我们称之为历史时区）。


All timezones in Haystack are repesented using the city name of an entry in the Olsen database.

原译：Haystack的所有时区都使用Olsen数据库中的一个条目的城市名进行**重新排列**。

校对：Haystack中的所有时区都使用Olsen数据库中的一个条目的城市名称**来表示**。


## 5) 单位
### 5.1 概述
All number tag values can be annotated with an optional unit. In addition, it is required to annotate each numeric point with the unit tag. In both cases, the unit must be an identifier defined by the standard unit database.  

原译：所有数字标签值都可以关联一个可选单位。此外，**还需要 point 使用 unit 标记注释每个数字**。在这两种情况下，单位必须是由标准单位数据库定义的标识符。  

校对：所有数字标签值都可以用一个可单位进行标注。此外，**需要使用 unit 标签对每个数字点进行标注**。在这两种情况下，单位必须是由标准单位数据库定义的标识符。  

### 5.2 单位系统
As a general principle, all the data associated with a given site should exclusively use either the SI metric system or the US customary system. Mixing unit systems within one site will cause serious headaches.  

原译：作为一般原则，与给定站点相关联的所有数据应仅使用SI度量系统或美国习惯系统。在一个场地内混合单元系统会引起严重的头痛。  

校对：作为一般原则，与给定站点相关联的所有数据应仅使用SI（国际单位制）度量系统或美国习惯系统（美式英制单位）。在同一个站点内混合使用不同的度量系统会引发很多麻烦。  

### 5.3 数据库
but has since been expanded to allow multiple aliases to be used for each unit.  

原译：但已经扩展到允许为每个**单元**使用多个别名。  

校对：但是已经被扩展到允许每个**单位**使用多个别名。  


Some units might have multiple symbols, for example "hour" has the symbols "hr" and "h". Some units like "day" have no symbols.  

原译：每个测量单位都有**全名和零个或多个符号，用作该单位的别名**。例如，“square_meter” 是全名，符号别名是 “m²” 。某些单位可能有多个符号，例如 “小时” 有符号 “hr” 和 “h”。有些单位如 “day” 没有符号。  

校对：每个测量单位都有**全名，以及零个或多个符号，这些符号作为该单位的别名**。例如，“square_meter”是全名，符号别名是“m²”。某些单位可能有多个符号，例如“hour”有符号“hr”和“h”。有些单位如“day”没有符号。 

解析：分清“单位”和“单位符号”；引号内保持原英文单位，不用翻译为中文


any Unicode char over 128  

原译：**任何Unicode字符超过128**  

校对：**所有编号超过128的Unicode字符**  


By convention the symbol is the preferred notation. If there are multiple symbols, then the last symbol defined by the database is the preferred one.  

原译：按照惯例，**符号是首选符号**。如果有多个符号，则数据库定义的最后一个符号是首选符号。

校对：按照惯例，**符号是首选的单位表示方法**。如果有多个符号，则将单位数据库中定义的最后一个作为首选符号。  

解析：分清“单位”和“单位符号”

### 5.4 常用单位
#### 杂项
percent, %（百分比）

#### 面积
square_meter, m²（平方米）  

square_foot, ft²（平方英尺）

#### 货币
australian_dollar, AUD（澳元）  

british_pound, GBP, £（英镑）  

canadian_dollar, CAD（加拿大元）  

chinese_yuan, CNY, 元  

euro, EUR, €（欧元）  

us_dollar, USD, $（美元）

#### 能源
kilowatt_hour, kWh（千瓦时）

#### 功率
kilowatt, kW（千瓦）

#### 压力
kilopascal, kPa（千帕）  

pounds_per_square_inch, psi（磅/平方英寸）  

inches_of_water, inH₂O（英寸水柱）  

inches_of_mercury, inHg（英寸汞柱）

#### 温度
fahrenheit, °F（华氏度）  

celsius, °C（摄氏度）

#### 温差
fahrenheit_degrees, Δ°F（华氏度）  

celsius_degrees, Δ°C（摄氏度）

#### 时间
millisecond, ms（毫秒）  

second, sec（秒）  

minute, min（分钟）  

hour, hr, h（小时）  

day（天）  

week, wk（周）  

julian_month, mo（朱利安月）  

year, yr（年）

#### 体积流量
liters_per_second, L/s（升/秒）  

cubic_feet_per_minute, cfm（立方英尺每分钟）


## 6) 网格
### 6.1 概述
Grids are two-dimensional tabular representations of tagged entities. We use grids as the core data model to serialize haystack tagged data over HTTP using the [Rest]() API.  

原译：网格是**标记实体**的二维表格表示。我们使用网格作为核心数据模型，使用 Rest API 通过HTTP序列化haystack标记的数据。  

校对：网格是**标签化实体**的二维表格形式。我们使用网格作为核心数据模型，并在 HTTP 层面使用[Rest]() API来序列化被 haystack 标记的数据。

### 6.2 结构 
One or more columns of a programmatic name and metadata  

原译：一个或多个编程名称和元数据列  

校对：一个或多个列，列包含可程序化的名称和元数据  

Zero or more Rows which are defined as scalar cells  

原译：零个或多个定义为标量单元格的行

校对：零个或多个行，行包含多个标量化的单元格  

Metadata is just a list of tags as name value pairs as specified by the [tag model](). Grid level metadata allows us to specify tags about the entire grid.

原译：元数据只是由 tag model 指定的**标签名称**列表。网格级元数据允许我们指定整个网格的标签。

校对：元数据只是由[标签模型]()指定的**键值对标签**的列表。网格级元数据允许我们指定关于整个网格的标签。

Columns are computed by the union of all unique tag names in a list of entities. Each column is composed of a programmatic name which must be a valid [tag name](). Columns may also specify metadata using tags. The [dis]() column tag may be used to provide a human friendly display name for the column (since the programmatic name will likely be camel case).

原译：列通过实体列表中所有唯一标签名称的并集计算。每列由编程名称组成，该名称必须是有效的 tag name。列也可以使用标签指定元数据。**`dis` 列标签可以被用来提供该列的人类友好的显示名称（因为编程名称将可能用驼峰方式表示）**。

校对：列通过实体列表中所有唯一标签名的并集计算**得出**。每列由编程名称组成，该名称必须是有效的[标签名称]()。列也可以使用标签指定元数据。**[dis]() 列标签可以用于为列提供人性化的显示名称（因为编程名称可能是驼峰式命名方式）**。

### 6.3 范例
Note the columns are union of all tags shared by the entities. Because not every entity shares the same columns, we have sparse or null cells. We could further add grid level or column level meta.

原译：请注意，列是**实体共享**的所有标签的并集。因为并不是每个实体共享相同的列，我们有空或者null的单元格。我们可以进一步添加网格级或列级元。

校对：请注意：列是**由实体贡献**的所有标签的并集。因为并不是每个实体共享相同的列，所以我们有空或 null 的单元格。我们可以进一步添加网格级或列级元数据。

解析：“实体共享”表示每个实体都有，原文并非此含义。


## 7) 过滤器
### 7.1 概述
Filters are used by the Rest [read op]() to perform ad hoc queries against a server.

原译：读操作使用过滤器来对服务器执行临时查询。

校对：Rest[读操作]()使用过滤器来对服务器执行临时查询。

### 7.2 用法
The scalars to compare against are encoded using [Zinc]() encoding (with couple exceptions noted below).

原译：要进行比较的标量是使用 Zinc 编码进行编码的（以下列出了几个例外）。

校对：要比较的标量是使用 [Zinc]() 格式进行编码的（除了以下几个例外）


You can combine filters using and, or, or not:

原译：可以使用组合过滤and，or或not：

校对：你可以使用 and，or 或 not进行组合过滤：


For example if your equip rec has a siteRef tag that references the site, you can query for equip in a given city

原译：如果你的 equip 记录有一个 siteRef 引用该网站的标签，您可以查询给定城市的设备

校对：如果您的 equip 记录有一个引用到站点的 siteRef 标签，则可以查询给定城市中的设备

The way to read the above expression is match an entity if:

+ it has equip tag
+ and it has a siteRef tag which is a Ref
+ and what the siteRef tag points to has the geoCity tag
+ and that the site's geoCity tag is equal to "Chicago"

原译：读取上述表达式的方式与这样一个实体相匹配：

+ 它有一个设备标签
+ 它有一个siteRef标签，它是一个Ref
+ 以及siteRef标记指向的是geoCity标记
+ 并且该网站的地理城市标签等于"芝加哥"

校对：读取上述表达式的方式是匹配一个实体，如果：

+ 它有一个 equip 标签
+ 并且它有一个 siteRef 标签，该标签是一个 Ref
+ 并且 siteRef 标签所指的站点含有 geoCity 标签
+ 并且该站点的 geoCity 标签等于 "Chicago"


### 7.3 语法
See [Zinc grammar]() for productions reused from Zinc. Note that Marker, Bin, and DateTime scalars are not supported. Bools are encoded as "true" or "false" (Zinc encodes as "T" or "F").

原译：参见 Zinc grammar，**用于从Zinc中重复使用的结果**。请注意，不支持Marker，Bin和DateTime标量。Bools编码为"true"或"false"（Zinc 编码为“T”或“F”）。

校对：**对于那些复用 Zinc 的软件产品**，可以参见[Zinc语法]()。请注意，它不支持Marker，Bin和DateTime标量。Bools被编码为“true”或“false”（Zinc将其编码为“T”或“F”）。


## 8) Zinc
### 8.1 概述
Zinc stands for "Zinc Is Not CSV". Zinc is a plaintext syntax for serializing Haystack grids using a souped up CSV format. Unlike [CSV](), Zinc supports typed scalar values (such as Bool, Int, Float, Str, Date, etc) and arbitrary meta-data at the grid and column level. Unlike JSON, Zinc results in much higher compression for tabular data.

原译：Zinc代表“Zinc不是CSV”。**Zinc是一种明文语法，用于使用加重CSV格式序列化Haystack网格**。与 CSV不同，Zinc支持类型的标量值（如Bool，Int，Float，Str，Date等）和网格和列级别的任意元数据。与JSON不同，Zinc对表格数据的压缩率要高得多。

校对：Zinc 表示“Zinc不是CSV”。**Zinc是一种用于序列化 Haystack 网格的纯文本语法，它使用一种增强的CSV格式**。与[CSV]()不同的是，Zinc支持有类型的标量值（如Bool，Int，Float，Str，Date等）以及网格和列级别的任意元数据。 它也与JSON不同，Zinc对表格数据的压缩率要高得多。

### 8.2 字面量
Literals

原译：**常量**

校对：**字面量**

解析：计算机术语，常量与字面量的区别


The basic syntax of Zinc uses a custom literal syntax for each type:

原译：Zinc的基本语法遵循如下规则

校对：在Zinc的基本语法中，为每种类型都使用了自定义的字面量语法


### 8.3 语法
There are two data rows each with a Str value for firstName and a Date value for bday.

原译：每个数据行都有一个Str值'firstName'和一个Date值'bday'。

校对：每个数据行包含firstName的Str值和bday的Date值。


It is common to have sparse tables where rows have a null value for a given column. This is indicated either using the N literal or by omitting a the cell entirely. For example these two rows are semantically identical:

原译：通常有稀疏表，**其中行对给定列具有空值**。这可以使用 **N 字符**或者完全省略来表示。例如下面这两行语义上相同

校对：通常会有稀疏表，**其中行的某些给定列是空值**。可以使用**字面量 N** 或者完全省略来表示。例如下面这两行在语义上是相同的


## 9) Json
### 9.1 概述
The JSON format is designed to support 100% fidelity with the full Haystack type system.

原译：JSON格式旨在通过完整的Haystack系统来支持100％的保真度。

校对：JSON格式能够完整地支持 Haystack 类型系统。

解析：原英文语义有问题。

### 9.2 类型映射
+ Number encodings use a space between the floating point value and unit for easier parsing (in Zinc there is no space)
+ Number specials use same values as Zinc: "INF", "-INF", and "NaN"
+ Refs strings use first space to separate id from dis portions of the string
+ DateTime, Date, and Time use ISO 8601 formats exactly as specified by Zinc

原译：
+ 数字编码使用浮点值和单位之间的空格来方便解析（在 Zinc 中没有空格）
+ 特殊**号码**使用与Zinc相同的值："INF"，"-INF"和"NaN"
+ **引用**字符串使用第一个空格将id与字符串的dis部分分开
+ **日期时间，日期和时间**使用完全按照Zinc指定的ISO 8601格式

校对：
+ 为了更方便解析，进行数字编码时，在浮点值和单位之间使用空格分隔（Zinc中没有空格）
+ 特殊**数字**使用与Zinc相同的值，如 "INF", "-INF", "NaN"
+ **Ref** 字符串使用第一个空格将id与字符串的dis部分分开
+ **DateTime，Date和Time**使用完全符合Zinc所指定的ISO 8601格式

### 9.3 网格格式
 we have a standard mapping of Grid into JSON which is used by the REST API.

 原译：我们还有一个 Grid 的标准映射到JSON，由REST API使用。

 校对：我们还有一个Grid到JSON的标准映射，供REST API使用。


+ Grid is mapped into a JSON object with three fields: meta, cols, rows
+ The meta field is a JSON object with a required "ver" field
+ The cols field is a JSON list of column objects
+ Each column object defines a "name" field and the column metadata
+ The rows field is a list of JSON objects
+ Meta and row dicts are mapped to JSON objects
+ Dict values are mapped using type mappings defined above

原译：
+ 网格被映射到具有三个字段的JSON对象：元，列，行
+ 元字段是具有必需的 "ver"字段的JSON对象
+ cols字段是列对象的JSON列表
+ 每个列对象定义一个 "name" 字段和列元数据
+ rows字段是JSON对象的列表
+ 元数据和行数据映射到JSON对象
+ **使用上面定义的类型映射映射标识值**

校对：
+ Grid被映射到具有三个字段的JSON对象：元（meta）、列（cols）、行（rows）
+ 元（meta）字段是一个必须含有 "ver" 字段的JSON对象
+ 列（cols）字段是一个列对象的JSON列表
+ 每个列（cols）对象定义一个 "name" 字段和列元数据（column metadata）
+ 行（rows）字段是一个JSON对象的列表
+ 元（Meta）数据和行（row）数据被映射到JSON对象
+ **字典（Dict）值的映射来自于上述类型映射**


Here is another example with nested lists, dicts, and grids:

原译：这里是另一个**集合，词典**和网格的示例

校对：这是另一个**嵌套列表、字典**和网格的例子：


## 10) Trio
### 10.2 格式
+ entities are separated by lines beginning with "-", the lines can have as many dashes as you want
+ string values may be left unquoted if they begin with a non-ASCII Unicode character or contain only the "safe" chars: A-Z, a-z, underbar, dash, or space
+ if a newline follows the colon, then the value is an indented multi-line string terminated by the first non-indented line
+ nested grids are encoded as a multi-line string prefixed with the string value "Zinc:" on the tag line

原译：
+ 实体以 "-" 开头的行分隔，**这些行可以具有所需的破折号**
+ 如果字符串值以非ASCII Unicode字符开头，**或仅包含“安全”字符A-Z，则可能不引用字符串值：a-z，，下划线，破折号或空格**
+ 如果换行符在冒号后面，**则该值是由第一个非缩进行终止的缩进多行字符串**
+ 嵌套网格被编码为**标记行**上以字符串值"Zinc："为前缀的多行字符串

校对：
+ 实体以“-”开头的行分隔，**这些行可以根据需要包含任意多个破折号**
+ 如果字符串值以非ASCII Unicode字符开头，**或仅包含“安全”字符如：A-Z，a-z，下划线，破折号或空格，则可能不引用字符串值**
+ 如果换行符在冒号后面，**则该值是多行缩进的字符串，并终止于第一个非缩进的行**
+ 嵌套网格被编码为**标签行**上以“Zinc:”字符串值开头的多行字符串


## 11) Csv
### 11.1 概述
CSV provides a simple way to get tabular data into other applications such as Excel.

原译：CSV提供了一种简单的方法来获取表格数据到其他应用程序，如Excel。

校对：CSV提供了一种将表格数据置入其他应用程序的简单方法，如Excel。


### 11.2 网格格式
Haystack defines a standard mapping of grids into CSV which is used by the [REST API](). Due to its simplicity, CSV does not provide full fidelity with the Haystack grid model -- metadata and type information is discarded.

原译：Haystack**将网格的标准映射定义为由[REST API]`Rest`使用的CSV** 。由于其简单性，CSV**不能完全保证Haystack网格模型** -- 元数据和类型信息被丢弃。

校对：Haystack**定义了供[REST API]()使用的网格到CSV的标准映射**。由于它很简单，CSV**不能为Haystack网格模型提供完整的保真度** -- 元数据和类型信息被丢弃。


+ First row is the column display names (programmatic names and meta is discarded)
+ Subsequent rows map to rows from the Grid
+ Marker cells are encoded as the Unicode checkmark code point U+2713
+ Null cells are encoded as the empty string
+ Ref cells are encoded as "@id dis", for example "@3ef7 Site-1"
+ Bools are encoded as "true" or "false"
+ Strs and Uris are encoded using their unescaped value
+ Everything else is encoded using its [Zinc]() encoding

原译：
+ 第一行是列显示名称（**程序名称**和元数据被丢弃）
+ 随后的行映射到网格中的行
+ **标记单元格被编码为Unicode复选标记代码点U + 2713**
+ **空**单元被编码为空字符串
+ Ref单元格被编码为"@id dis"，例如"@ 3ef7 Site-1"
+ Bools被编码为"true"或"false"
+ Strs和Uris使用它们的未转义值进行编码
+ **一切都**使用其 [Zinc]() 编码进行编码


校对：
+ 第一行是列的显示名称（**编程名称**和元数据被丢弃）
+ 随后的行映射到网格中的行
+ **标记单元格被编码为Unicode的 ✓ 号，其Unicode码为U+2713**
+ **Null** 单元格被编码为空字符串
+ Ref 单元格被编码为“@id dis”, 例如“@3ef7 Site-1”
+ Bool 被编码为“true”或“false”
+ Str 和 Uri 使用它们的未转义值进行编码
+ **其他的都**使用其[Zinc]()格式进行编码


































